<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Bluepill: a GCC/CMake build environment ..</title>
<!-- 2018-09-04 Tue 18:29 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="George Kontsevich" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../static/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Bluepill: a GCC/CMake build environment ..</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Intro</a>
<ul>
<li><a href="#sec-1-1">Prior Art</a></li>
</ul>
</li>
<li><a href="#sec-2">Anatomy of a build</a>
<ul>
<li><a href="#sec-2-1">The Linker Script</a></li>
<li><a href="#sec-2-2">The Startup File (WIP)</a></li>
<li><a href="#sec-2-3">The STM Libraries</a></li>
<li><a href="#sec-2-4">Our blinky code (WIP)</a></li>
<li><a href="#sec-2-5">The toolchain</a></li>
</ul>
</li>
<li><a href="#sec-3">Getting the code on the chip</a>
<ul>
<li><a href="#sec-3-1">Building</a></li>
<li><a href="#sec-3-2">OpenOCD</a></li>
</ul>
</li>
<li><a href="#sec-4">Intergrated Development</a>
<ul>
<li><a href="#sec-4-1">GDB</a></li>
<li><a href="#sec-4-2">KDevelop</a>
<ul>
<li><a href="#sec-4-2-1">Extras</a></li>
</ul>
</li>
<li><a href="#sec-4-3">toolchain quirks</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Intro</h2>
<div class="outline-text-2" id="text-1">
<p>
In this guide we will setup a simple minimal blinky for the Bluepill: A very cheap board available from China with the <code>STM32F103C8T6</code> chip on it. They cost a smidge over one dollar each
</p>


<div class="figure">
<p><img src="bluepill.jpeg" alt="bluepill.jpeg" />
</p>
</div>

<p>
I will have two versions - one using the CMSIS and one using the LL (explained below). The embedded community seems a bit allergic to CMake - but I'm quite allergic to Make, so hopefully this guide will provide something new.
</p>

<p>
starting our CMake file we write out the usual
</p>

<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">cmake_minimum_required</span>(VERSION 3.0)
<span style="color: #ef2929;">project</span>(blinky)
</pre>
</div>

<p>
The blessed way of building things for the STM32 series chips is using their wizards - but it's possible to get the whole thing running just using GCC and OpenOCD - and that's what we're gunna try to get working by the end of this guide. People have ofcourse already done this before:
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Prior Art</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li><code>dwelch67</code> has some great extremely minimal setups for the blue pilll on <a href="https://github.com/dwelch67/stm32_samples/tree/master/STM32F103C8T6">his github</a>. He describes them extensively in a <a href="https://electronics.stackexchange.com/questions/30736/stm32f2-makefile-linker-script-and-start-up-file-combination-without-commercia">few places on Stack Overflow</a>. Basically here he rolls his own .. everything. It's very greybeard. All the code is in your face - no libraries. Straight writting to registers. Definitely take a look!
</li>

<li><code>PurpleAlien</code> has another setup - which is very close to what I'm doing. He described it <a href="https://www.purplealienplanet.com/node/69">on his website</a> and the code is on the <a href="https://github.com/PurpleAlien/stm32-minimal">his github</a>. It's a slightly different chip - but the steps should work almost identically for the <code>bluepill</code>.
</li>

<li><code>satoshinm</code> has <a href="https://satoshinm.github.io/blog/171212_stm32_blue_pill_arm_development_board_first_look_bare_metal_programming.html">a wonderful guide</a> where he guides you through all the challenges he had setting up his bluepill. It's long but very informative and I recommend reading it. He also has an accompanying repository where we has code for the blinky working using bare metal, the STM HAL and another 3rd party library. His code (the bare metal part especially) was absolutely invaluable for getting my setup up and running. Check out <a href="https://github.com/satoshinm/pill_blink">his github</a> project.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Anatomy of a build</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">The Linker Script</h3>
<div class="outline-text-3" id="text-2-1">
<p>
When an application normally runs on a desktop machine it's generally running using virtual memory in a virtual application-specific address space. From the applications point of view it can manipulate it's own memory however it wants - and it's the operating system that then translates that into safe operations on the actually memory (for instance to insure that the applications doesn't touch any memory region it shouldn't)
</p>

<p>
On a simple microcontroller there is no operating system to manage the memory, and the memory is shared with other functionality - some addresses are reserved for peripherals, other addresses are for interrupts and reset bits, the stack and heap are allocated some device-specific place and there is also a split between ROM and RAM. 
</p>

<p>
Because of these new limitations we can't just start executing code at address zero  or drop in a <code>main()</code> functions somewhere randomly and start there, we need to tell the linker what the code layout is though a custom <b>linker script</b>. First we tell it which parts are ROM and RAM with their respective sizes. ROM (Read Only Memory) is where the code and constants live, and RAM (Random Access Memory) is where the stack and heap live - the stuff that's dynamic
</p>

<div class="org-src-container">

<pre class="src src-c">MEMORY
{
    rom (rx) : ORIGIN = 0x08000000, LENGTH = 64K
    ram (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
}
PROVIDE(_stack = ORIGIN(ram) + LENGTH(ram));
</pre>
</div>

<p>
Even give that, code on a microcontroller doesn't by default start at the first address of ROM and go from there (that's more or less how we conceptualize code running on an normal OS). A better way to think about the microcontroller is it's as a machine that recieves interrupt signals from external inputs and the chip responding by running code and then returning to whatever it was doing before. These interrupting inputs can be a clock running out, a peripheral wanting attention, an attached debugger wanting a halt, etc.
</p>

<p>
So instead of a <code>main()</code> or something, the first thing in ROM is a vector table - a table of pointers to the different <b>interrupt handlers</b> - ie. the code that is run when each interrupt happens. So we need to tell the linker that there will be a vector table
</p>
<div class="org-src-container">

<pre class="src src-c">EXTERN(vector_table);
</pre>
</div>
<p>
Here <code>vector_table</code> is  not a special keyword, it's just a label we are giving to the linker. It's written as <code>EXTERN</code>, meaning it has the label name now, but it'll look for its definition in our code, so we need to not forget to define this later on!
</p>

<p>
The first interrupt handler in this table will be special and it's the one that is triggered when the system is powered on, the user presses the reset button, or the code runs out of things to do. It's appropriately called the <b>reset handeler</b>
</p>

<p>
We also tell the linker that the code should start at the <b>reset handler</b>. Though as we'll see in the next section, this isn't stictly necessary because the reset handler is always the first interrupt handler in the vector table - so the microcontroller will know where to look for it by default.
</p>
<div class="org-src-container">

<pre class="src src-c">ENTRY(reset_handler);
</pre>
</div>
<p>
Again, this is just a symbol and the linker will look for its value in our code during linking.
</p>

<p>
Lastly we need to tell the linker that we want those vectors first in the ROM and aligned at the byte level (b/c the micro reads things in byte sized chucks - haha)
</p>
<div class="org-src-container">

<pre class="src src-c">SECTIONS
{
    .text : {
        *(.vectors)
        *(.text*)
        . = ALIGN(4);
    } &gt;rom
}
</pre>
</div>
<p>
So the chip doesn't need to hunt for the vector table. It's always in the same spot - and the reset handler is as well.
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">The Startup File (WIP)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The next part is to actually write the reset handler and to define the vector tables we just talked about and that the linker is expecting from us! The vector table will be set to some default values (and can be changed later) and we'll write the reset handler in a generic way that we can reuse between project. It will do some generic initializations and then at the end call to <code>main()</code>. Then when we start a new project we can simply start writing a <code>main()</code> and skip all this initializations. In so doing we've split off these initializations into a separate <b>startup file</b> that we will reuse across projects.
</p>

<blockquote>
<p>
<b>Note:</b> There is nothing special about this file for the compiler or linker - it's just another code file - and  you are free to copy it over to your other code files if you want!
</p>
</blockquote>
<div class="org-src-container">

<pre class="src src-c">  <span style="color: #18b2b2;">int</span> <span style="color: #ef2929;">main</span>(<span style="color: #18b2b2;">void</span>);
  <span style="color: #18b2b2;">void</span> <span style="color: #00af00;">__attribute__</span> ((weak, naked)) <span style="color: #ef2929;">reset_handler</span>(<span style="color: #18b2b2;">void</span>) {
      (*(<span style="color: #00af00;">volatile</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">int</span> *)(0x40021018)) |= (1 &lt;&lt; 4);

      (*(<span style="color: #00af00;">volatile</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">int</span> *)(0x40011004)) |= (0x00 &lt;&lt; (((13 - 8) * 4) + 2));
      (*(<span style="color: #00af00;">volatile</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">int</span> *)(0x40011004)) |= (0x02 &lt;&lt; ((13 - 8) * 4));
      main();
  }

<span style="color: #18b2b2;">void</span> <span style="color: #ef2929;">blocking_handler</span>(<span style="color: #18b2b2;">void</span>) { <span style="color: #00af00;">while</span> (1); }
<span style="color: #18b2b2;">void</span> <span style="color: #ef2929;">null_handler</span>(<span style="color: #18b2b2;">void</span>) {}
<span style="color: #00af00;">extern</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #ff8700;">_stack</span>;

<span style="color: #00af00;">__attribute__</span> ((section(<span style="color: #ff1f8b;">".vectors"</span>)))
<span style="color: #00af00;">struct</span> {
    <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">int</span> *<span style="color: #ff8700;">initial_sp_value</span>;
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">reset</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">nmi</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">hard_fault</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">memory_manage_fault</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">bus_fault</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">usage_fault</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">reserved_x001c</span>[4])(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">sv_call</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">debug_monitor</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">reserved_x0034</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">pend_sv</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">systick</span>)(<span style="color: #18b2b2;">void</span>);
    <span style="color: #18b2b2;">void</span> (*<span style="color: #ef2929;">irq</span>[68])(<span style="color: #18b2b2;">void</span>);
} <span style="color: #ff8700;">vector_table</span> = {
    .initial_sp_value = &amp;_stack,
    .reset = reset_handler,
    .nmi = null_handler,
    .hard_fault = blocking_handler,

    .sv_call = null_handler,
    .pend_sv = null_handler,
    .systick = null_handler,
    .irq = {
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
        null_handler,
    }
};
</pre>
</div>
<p>
If you open up some startup files in templates provided by STM you will see that they're all written in assembly. The rational is that because the resulting code is always the same there no chance of the compiler doing something funny. However if you squint and look at the assembly you will see that the code is doing basically the same thing. It defined a reset handler which then calls a main.
</p>

<p>
Once we have the file we can add it to CMake
</p>
<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">enable_language</span>(ASM)
<span style="color: #ef2929;">set</span>(STARTUP_FILE <span style="color: #ff1f8b;">"startup_stm32f103xb.c"</span>)
</pre>
</div>
<blockquote>
<p>
<b>TODO</b> Explain what's going on in more details
<b>TODO</b> Maybe split all of this generic stuff into a separate repository that can be pulled in with CMake. If I write a <code>configure_elf()</code> cmake function that will do all this messy stuff, it'd keep the parent project <code>CMakeLists.txt</code> a lot cleaner. 
</p>
</blockquote>
<blockquote>
<ul class="org-ul">
<li>This module performs:
</li>
<li>- Set the initial SP
</li>
<li>- Set the initial PC == Reset<sub>Handler</sub>,
</li>
<li>- Set the vector table entries with the exceptions ISR address
</li>
<li>- Configure the clock system   
</li>
<li>- Branches to main in the C library (which eventually
</li>
<li>calls main()).
</li>
</ul>
</blockquote>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">The STM Libraries</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Next we need actual libraries to write code with - otherwise we are kinda stuck writing assembly and poking at memory addresses with the datasheet. These are all provided in one bundle called <b>Cube</b> and it's on <a href="https://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-mcu-packages/stm32cubef1.html">the STM website</a>. Here is a quick digest of what you get:
</p>

<ul class="org-ul">
<li>The <b>BSP</b> has board specific peripheral libraries.. since we aren't using a board from STM - this really doesn't concern us.
</li>

<li>The <b>HAL</b> that comes from STM is the standard <b>Hardware Abstraction Layer</b>. It will be making some simplifying assumptions and do some stuff more automatically for you. I'm going to skip setting this up. Blinking a light should be pretty simple - so I'm shooting to get it working with simpler APIs
</li>

<li>Hidden inside of the <b>HAL</b> folder you will see files that are names <code>stm32f1xx_ll_*.c/h</code>. These actually form a seperate sub-library of sorts called the  <b>LL</b> API (for <b>Low Level</b>)
</li>

<li>The <b>CMSIS</b> ( Cortex Microcontroller Software Interface Standard ) : This library comes from ARM (<i>not STM</i>). It's split into several semi-independent components and provides a common base for all ARM devices (independent of vendor). The <b>HAL</b> and <b>LL API</b> are built on top of the <b>CMSIS</b>
</li>
</ul>

<p>
Both the <b>HAL</b> and <b>CMSIS</b> need some chip-specific configuration - b/c while the API is standard, under the hood things will change from chip to chip (like memory addresses of things or clock information). I've bundled the <b>LL API</b> and the <b>CMSIS</b> together in a separate project <a href="https://geokon-gh.github.io/stm32f1-ll/index.html">stm32f1-ll</a> (<a href="https://github.com/geokon-gh/stm32f1-ll/">github</a>). It's also building with CMake so we can use it directly in our project (and you can skip registration and downloading the <b>Cube</b> thing). I recommend checking out that project's webpage for more details on how it works - but there is very little magic going on. 
</p>

<p>
The library bundle has been added as a submodule to this project, but if you forgot to clone recursively you can clone it right now into the project root with <code>git clone https://github.com/geokon-gh/stm32f1-ll/</code>. Once we have it there we can just add it in
</p>

<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">add_subdirectory</span>(stm32f1-ll)
</pre>
</div>

<blockquote>
<p>
<b>Note</b>:in <code>STM32Cube_FW_F1_V1.6.0/Middlewares</code> there are additional libraries that sorta live on top of all of this and do more complicated stuff like TCP/IP USB..stuff and Filesystem things. Basically things that are kinda complicated you probably want to avoid writing yourself. I'm completely skipping this :)
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Our blinky code (WIP)</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Next we can write a little program to blink a light and put it into <code>/src/main.c</code>
</p>

<p>
TODO: Write my own :)
Ripped directly from <a href="https://github.com/satoshinm/pill_blink/blob/master/bare-metal/pill_blink.c">https://github.com/satoshinm/pill_blink/blob/master/bare-metal/pill_blink.c</a> for now&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-c"><span style="color: #18b2b2;">int</span> <span style="color: #ef2929;">main</span>(<span style="color: #18b2b2;">void</span>){
    <span style="color: #00af00;">while</span>(1) {
        (*(<span style="color: #00af00;">volatile</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">int</span> *)(0x40011010)) = (1 &lt;&lt; 13);
        <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; 1000000; ++i) <span style="color: #00af00;">__asm__</span>(<span style="color: #ff1f8b;">"nop"</span>);

        (*(<span style="color: #00af00;">volatile</span> <span style="color: #18b2b2;">unsigned</span> <span style="color: #18b2b2;">short</span> *)(0x40011014)) = (1 &lt;&lt; 13);
        <span style="color: #00af00;">for</span> (<span style="color: #18b2b2;">int</span> <span style="color: #ff8700;">i</span> = 0; i &lt; 500000; ++i) <span style="color: #00af00;">__asm__</span>(<span style="color: #ff1f8b;">"nop"</span>);
    }
}
</pre>
</div>
<p>
Once there we can just add it as a special executable into our cmake
</p>
<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">add_executable</span>(${<span style="color: #ff8700;">PROJECT_NAME</span>}.elf ${<span style="color: #ff8700;">STARTUP_FILE</span>}
  src/main.c)
<span style="color: #ef2929;">target_include_directories</span>(${<span style="color: #ff8700;">PROJECT_NAME</span>}.elf PUBLIC inc)
</pre>
</div>
<p>
and then link it to our library
</p>
<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">target_link_libraries</span>(${<span style="color: #ff8700;">PROJECT_NAME</span>}.elf ll )
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">The toolchain</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Now that we have the code to start up the chip and the code to blink a light we just need to specify the compiler and flags we will run. I'm building using <code>gcc-arm-none-eabi</code> and its associated tools. I did this on a Debian system where this version of gcc can be installed from the repository (name <code>gcc-arm-none-eabi</code>)
</p>

<p>
Canonically this is done in a separate file so that you can subsitute other possible toolchains (like for instance LLVM or custom versions of GCC). We won't be doing that here, but for the sake of convention I've written these configurations to a <code>toolchain.cmake</code>
</p>

<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">set</span>(CMAKE_SYSTEM_NAME Generic) <span style="color: #b2b2b2; font-style: italic;"># 'Generic' is used for embedded systems</span>

<span style="color: #ef2929;">set</span>(CMAKE_C_COMPILER arm-none-eabi-gcc)
<span style="color: #ef2929;">set</span>(CMAKE_CXX_COMPILER arm-none-eabi-g++)
<span style="color: #ef2929;">set</span>(CMAKE_ASM_COMPILER arm-none-eabi-gcc)

<span style="color: #b2b2b2; font-style: italic;"># tells CMake not to try to link executables during its interal checks</span>
<span style="color: #b2b2b2; font-style: italic;"># things are not going to link properly without a linker script</span>
<span style="color: #ef2929;">set</span>(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

<span style="color: #ef2929;">set</span>(CMAKE_OBJCOPY arm-none-eabi-objcopy)
<span style="color: #ef2929;">set</span>(CMAKE_OBJDUMP arm-none-eabi-objdump)
<span style="color: #ef2929;">set</span>(CMAKE_SIZE arm-none-eabi-size)
<span style="color: #ef2929;">set</span>(CMAKE_DEBUGGER arm-none-eabi-gdb)
<span style="color: #ef2929;">set</span>(CMAKE_DEBUGGER arm-none-eabi-gdb)
<span style="color: #ef2929;">set</span>(CMAKE_CPPFILT arm-none-eabi-c++filt)
</pre>
</div>
<p>
If you skip writing a toolchain file then CMake will default to the system compiler and things will start to slowly go wrong for you (it generally doesn't blow up into your face here)
</p>

<p>
Next we need to tell the linker what linker script to use (which is a bit ugly in CMake)
</p>

<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">set_target_properties</span>(
  ${<span style="color: #ff8700;">PROJECT_NAME</span>}.elf
  PROPERTIES
  LINK_FLAGS
  <span style="color: #ff1f8b;">"-T${</span><span style="color: #ff8700;">PROJECT_SOURCE_DIR</span><span style="color: #ff1f8b;">}/STM32F103RBTx_FLASH.ld \</span>
<span style="color: #ff1f8b;">   -Wl,--gc-sections \</span>
<span style="color: #ff1f8b;">   -Wl,-Map=${</span><span style="color: #ff8700;">PROJECT_NAME</span><span style="color: #ff1f8b;">}.map"</span>)
</pre>
</div>

<p>
I'm appending this to the <code>CMakeLists.txt</code>, but it's maybe something that should be in the toolchain file.
</p>

<p>
I also added two more linker options (you can see it's a linker option b/c it starts with a <code>-Wl</code>)
</p>

<ul class="org-ul">
<li><code>--gc-sections</code> this tells the linker to remove unused code/data from the final executable. There is a pesky <code>_exit()</code> function referrence that will often get slipped into your executable by the compiler. B/c we are running on a microcontroller the code never exits (it can't quit and hand off executation to an OS after all!) so this exit needs to be removed by the linker. Otherwise the linker will complain you never defined an exit function.
</li>

<li><code>-Map</code> prints a link map:
<ul class="org-ul">
<li>Where object files and symbols are mapped into memory.
</li>
<li>How common symbols are allocated.
</li>
<li>All archive members included in the link, with a mention of the symbol which caused the archive member to be brought in.
</li>
</ul>
</li>
</ul>

<p>
The link map is like a high-level overview of how your code looks like
</p>

<p>
More linker options are explained in details here: <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html">https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html</a>
</p>


<p>
We then also need to let the compiler know our target architecture and some compiler options (taken from <a href="https://github.com/PurpleAlien/stm32-minimal/blob/master/Makefile">PurpleAlien</a>)
</p>

<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">target_compile_options</span>(${<span style="color: #ff8700;">PROJECT_NAME</span>}.elf PUBLIC
  -Wall 
  -g 
  -std=gnu99 
  -Os
  -mthumb
  -mcpu=cortex-m3
  -mfloat-abi=soft
  -mlittle-endian
  -ffunction-sections 
  -fdata-sections
  -Werror 
  -Wstrict-prototypes 
  -Warray-bounds 
  -fno-strict-aliasing 
  -Wno-unused-const-variable 
  -specs=nano.specs 
  -specs=nosys.specs)
</pre>
</div>
<p>
<b>TODO</b> Explain all of these&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Getting the code on the chip</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Building</h3>
<div class="outline-text-3" id="text-3-1">
<p>
At this point we have all the files we need to build the code, so just go to a new empty directory and run
</p>

<pre class="example">
cmake -DCMAKE_TOOLCHAIN_FILE=path/to/source/toolchain.cmake /path/to/source/
make
</pre>

<p>
Now in the build directory you'll have some build garbage, the link map <code>blinky.map</code> and <code>blinky.elf</code> - which is the code/executable that we want to get onto the bluepill.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">OpenOCD</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The standard open source software for flashing the bluepill is OpenOCD. On fancier/more-expensive boards there will be a secondary chip that helps you flash the microcontroller. But on cheaper and more practical chips this part is omitted (b/c in a sense it's a waste to have the same chip on every single board). So to flash the bluepill you will need something to do the flashing with. I'm using a knock off <code>ST-LINK v2</code> I purchased on Taobao. (note the wiring is in a different order on the board and programmer)
</p>


<div class="figure">
<p><img src="st-link.jpeg" alt="st-link.jpeg" />
</p>
</div>

<p>
OpenOCD will provide us with an abstraction layer. It will communicate over JTAG or SWD to the chip and we will communicate with OpenOCD and tell it what we need. 
</p>

<p>
The software setup is rather baroque - but the <a href="http://openocd.org/documentation/">documentation</a> is very thorough. You start from the beginning and just read very carefully sequentially and it will all make sense. Fortunately for us - the hardware we're using is very standard so we can use some already provided templates. When I install OpenOCD on my Debian system through <code>apt-get install openocd</code> the templates are in <code>/usr/share/openocd/scripts/board/</code>. After browsing some similar boards (like the stm32f4disovery) you kinda get the picture of how the configuration file should look (<b>THESE VALUES CHANGE BETWEEN POINT RELEASE OF OPENOCD. DOUBLE CHECK THEM IF YOU HAVE ANY ISSUES</b>)
</p>

<p>
Note that for the file to run automatically when you type <code>openocd</code> in the shell, you need to save the configuration to a file called <code>openocd.cfg</code> 
</p>
<div class="org-src-container">

<pre class="src src-c">source [find interface/stlink-v2.cfg]
transport select hla_swd
source [find target/stm32f1x_stlink.cfg]
program blinky.elf verify reset exit
</pre>
</div>
<p>
The configuration is not too complicated. It sets the interface type (ie the ST-LINK flashing dongle thing), then it sets the flashing communication protocol for talking to the chip, then the actual chip type and lastly we tell it to program the chip with the <code>.elf</code> we just made. After flashing it will verify the code, reset the controller and then exit OpenOCD
</p>

<p>
For convenience we should also tell CMake to copy this file over to the build directory
</p>
<div class="org-src-container">

<pre class="src src-cmake"><span style="color: #ef2929;">file</span>(COPY
  openocd.cfg
  DESTINATION
  ${<span style="color: #ff8700;">CMAKE_BINARY_DIR</span>})
</pre>
</div>

<p>
So now in our build directory we simply run <code>openocd</code> and your program should magically upload to the chip and start running. The light should be flashing at this point :)
</p>

<p>
Some things to double check:
</p>
<ul class="org-ul">
<li>The version of OpenOCD you are running&#x2026; I had weird issues with manually installed OpenOCDs, but the repo one worked great
</li>
<li>Check the templates - if you have problems, try some of the other options available
</li>
<li>try running OpenOCD as root! Maybe your user doesn't have the right USB permissions or something to that effect
</li>
<li>I had weird connection issues that turned out to be due to faulty wires! Thanks to <a href="https://reddit.com/comments/9ba9n8/comment/e53aa2m?context=3">NeoMarxismIsEvil</a> for catching that :)
</li>
<li>In the next section about GDB I mention an <code>unlock</code> command.. I'm not 100% sure it's necessary - but try it if you're having issues
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Intergrated Development</h2>
<div class="outline-text-2" id="text-4">
<p>
One of the big bonuses of this setup is that it will hook into existing tools very easily.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">GDB</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The first basic step is hookin' up a debugger.
</p>

<p>
For some reason Debian Testing is missing a <code>arm-none-eabi-gdb</code>, so I had to just download the whole GCC toolchain from <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">ARM's website</a> (this only works assuming you're running on a x64 machine). Just make sure you don't just run the system GDB! It won't throw you any errors and it will kinda work.. till it doesn't. 
</p>

<p>
Once we have the right version of <b>GDB</b> the next part becomes super easy b/c by default <b>OpenOCD</b> will provide us with a GDB server to which we can connect. We just need to disable the part where we flash the program and exit and replace it with a command to reset the chip and stop
</p>

<div class="org-src-container">

<pre class="src src-c">source [find interface/stlink-v2.cfg]
transport select hla_swd
source [find target/stm32f1x_stlink.cfg]
reset_config srst_nogate
</pre>
</div>

<p>
I honestly didn't entirely understand all the reset configuration options so if you're having issues I'd suggest looking at <a href="http://openocd.org/doc/html/Reset-Configuration.html">the documentation</a> and trying several different settings. I've found the current one works for me. Again, we just run <code>openocd</code> but this time the program kinda hangs and sits and waits for a connection:
</p>

<blockquote>
<p>
$ openocd 
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        <a href="http://openocd.org/doc/doxygen/bugs.html">http://openocd.org/doc/doxygen/bugs.html</a>
WARNING: target/stm32f1x<sub>stlink</sub>.cfg is deprecated, please switch to target/stm32f1x.cfg
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
adapter speed: 1000 kHz
adapter<sub>nsrst</sub><sub>delay</sub>: 100
none separate
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v17 API v2 SWIM v4 VID 0x0483 PID 0x3748
Info : using stlink api v2
Info : Target voltage: 2.913562
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
</p>
</blockquote>

<p>
We open another terminal and run our <code>arm-none-eabi-gdb</code> The next few steps will connect to the OpenOCD server, stop the program running on it, unlock the chip, and load our new program
</p>

<pre class="example">
&gt; target remote localhost:3333
&gt; monitor reset halt
&gt; monitor stm32f1x unlock 0
&gt; load blinky.elf
</pre>

<p>
Now you can set breakpoint, run code, inspect the stack and variables, etc. etc. Look at the GDB manual for all the juicy details - and don't forget about the very handy <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb-5.1.1/html_chapter/gdb_19.html">TUI Mode</a>. Start it with <code>C-x C-a</code>, then hit <code>C-x 2</code> to bring up the assembly. And type <code>s</code> to step one line of code at a time and <code>si</code> to step one assembly instruction at a time!
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">KDevelop</h3>
<div class="outline-text-3" id="text-4-2">
<p>
To demonstrate how flexible things get thanks to CMake, next I'll show you how to setup KDevelop to run everything for us. In principle this should work equally well with QtCreator or CLion or CQuery/Emacs. This isn't an endorsement of KDevelop over the alternatives b/c is sorta like Visual Studio - a big drop-box driven mess - but I'm just familiar with it and it's quick and easy to get up and running with a CMake project. We'll be able to jump around our code and refactor things in no time. The easiest way to get started is to just get the KDevelop AppImage from <a href="https://www.kdevelop.org/download">their website</a>. Download it, make it executable with <code>chmod +x $KDevelopAppImageFile</code> and run!
</p>

<p>
Next you click <i>Project</i> &gt; <i>Open - Import Project</i>  and the navigate to a copy of this repository where the <code>CMakeLists.txt</code> resides. It should automatically give you a window with the project name and with the CMake Project Manager. Just hit <i>Finish</i> on the bottom row and you will get another window to set up your CMake configuration. Here you need:
</p>

<ul class="org-ul">
<li>Select a build directory 
<ul class="org-ul">
<li>I typically don't go with the default (b/c my code resides on a USB drive) and I build somewhere else on my main disk. Always using a <code>project_name/build</code> directory encourages people to write sloppy build files that reach into the repository (b/c you can always go <code>../</code> from the <code>/build/</code> folder to get to the repository files). But you shouldnt' write code/configurations that assume their built location ;)
</li>
</ul>
</li>
<li>The installation prefix can be left blank 
<ul class="org-ul">
<li>CMake is a bit weird in that it's not just a build tool, but it also has these unnecessary installation features that keep cropping up
</li>
</ul>
</li>
<li>Build Type 
<ul class="org-ul">
<li>This part I don't 100% understand at the moment.. but I think you can go with <b>Release</b> here. GDB seems to somehow magically find the matching source code on its own even when you build with no symbols. But if you have issues with debugging don't hesitate to switch to <b>Debug</b>
</li>
</ul>
</li>
<li>Provide extra arguments to CMake 
<ul class="org-ul">
<li>Here we need to tell CMake about our toolchain. Unfortunately a lot of people don't use toolchain files - as you always always should - and they just go with the random system defaults. KDevelop seems to encourage this further by not providing a field for the toolchain file..  so you need to add a <code>-DCMAKE_TOOLCHAIN_FILE=/path/to/your/project/directory/bluepill/toolchain.cmake</code> in the extra arguments area here (yeah.. this is a bit clunky..)
</li>
</ul>
</li>
</ul>

<p>
Then just hit <i>Run</i> and the wheels should start turning. It will load in your whole project and then index your code + LL/CMSIS libraries for a few minutes. At this point you can already hit <i>Build</i> in the top left and make that <code>elf</code> file like we did from the command line. Infact, underthe hook KDevelop is doing exactly what we did before manually. If you <code>cd</code> to your build directory you can still run <code>make</code> by hand if you want
</p>

<p>
But now we are also getting the benefits of CMake. You can now click on variables, jump around the code and get all the fancy syntax highlighting you expect in a desktop program
</p>
</div>


<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">Extras</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
KDevelop unfortuantely has some very bizarre default working directories in their configurations&#x2026;
</p>
</div>

<ul class="org-ul"><li><a id="sec-4-2-1-1" name="sec-4-2-1-1"></a>Execute<br  /><div class="outline-text-5" id="text-4-2-1-1">
<p>
To make the <i>Execute</i> button flash the program to the chip go to <i>Run</i> &gt; <i>Configure Launches&#x2026;</i> and then hit <i>+ Add</i> in the top left and select your target's name from the drop down menu (mine is called <code>blinky.elf</code>). In the new screen on the right side, you want to change the <i>Executable</i> from <b>Project Target</b> to <b>Exectuable</b> and then put in <i>the full path</i> to openocd (mine is <code>/usr/bin/openocd</code>). We also need to set the <i>Working Directory</i> to be the build directory so it can find the <code>openocd.cfg</code> file we made. So now when we hit <b>Execute</b> on the top bar it will just run <code>openocd</code> in the build directory. The way we've set things up, this should flash the chip!
</p>
</div>
</li>

<li><a id="sec-4-2-1-2" name="sec-4-2-1-2"></a>Debug (WIP)<br  /><div class="outline-text-5" id="text-4-2-1-2">
<p>
In that same window you will notice there is a <b>Debug</b> submenu on the left under our target executable. It's probably possible to get the <code>OpenOCD/GDB</code> setup running here as well - but unfortunately here things just got too ugly for me and I couldn't find a sane way to set this up (and I kept having issues where KDevelop wasn't cleaning up the OpenOCD processes correctly). If you find a clean way to get this working then please make an issue/PR and tell me about it :)
</p>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">toolchain quirks</h3>
<div class="outline-text-3" id="text-4-3">
<p>
<b>Note:</b> Interestingly if I have my toolchain file pointing at the precompiled GCC files from ARM, my final <code>elf</code> file ends up looking different when I flash the chip
</p>

<p>
Using ARM's precompiled GCC <code>v.7.3.1</code> :
</p>
<pre class="example">
(gdb) load blinky.elf
Loading section .isr_vector, size 0x10c lma 0x8000000
Loading section .text, size 0x4bc lma 0x800010c
Loading section .rodata, size 0x4 lma 0x80005c8
Loading section .init_array, size 0x8 lma 0x80005cc
Loading section .fini_array, size 0x4 lma 0x80005d4
Loading section .data, size 0x434 lma 0x80005d8
Start address 0x800017c, load size 2572
Transfer rate: 10 KB/sec, 428 bytes/write.
</pre>

<p>
Using the Debian repository GCC <code>v.6.3.1</code>:
</p>
<pre class="example">
(gdb) load blinky.elf
Loading section .isr_vector, size 0x10c lma 0x8000000
Loading section .text, size 0x52c lma 0x800010c
Loading section .rodata, size 0x4 lma 0x8000638
Loading section .init_array, size 0x8 lma 0x800063c
Loading section .fini_array, size 0x4 lma 0x8000644
Loading section .data, size 0x434 lma 0x8000648
Start address 0x80003e4, load size 2684
Transfer rate: 10 KB/sec, 447 bytes/write.
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: George Kontsevich</p>
<p class="date">Created: 2018-09-04 Tue 18:29</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
