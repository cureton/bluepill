#+TITLE: Bluepill: a GCC/CMake build environment ..
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../static/worg.css" />
#+options: num:nil
# This will export a README.org file for Github, so that people that land in my repo know where to find the relevant webpage
#+BEGIN_SRC org :tangle README.org :exports none
  see description [[http://geokon-gh.github.io/bluepill/index.html][here]]
#+END_SRC

* Intro
In this guide we will setup a simple minimal blinky for the Bluepill: A very cheap board available from China with the =STM32F103C8T6= chip on it. They cost a smidge over one dollar each

[[file:bluepill.jpeg]]

I will have two versions - one using the CMSIS and one using the LL (explained below). The embedded community seems a bit allergic to CMake - but I'm quite allergic to Make, so hopefully this guide will provide something new.

starting our CMake file we write out the usual

#+BEGIN_SRC cmake :tangle CMakeLists.txt
  cmake_minimum_required(VERSION 3.0)
  project(blinky)
#+END_SRC

The blessed way of building things for the STM32 series chips is using their wizards - but it's possible to get the whole thing running just using GCC and OpenOCD - and that's what we're gunna try to get working by the end of this guide. People have ofcourse already done this before:

** Prior Art

- =dwelch67= has some great extremely minimal setups for the blue pilll on [[https://github.com/dwelch67/stm32_samples/tree/master/STM32F103C8T6][his github]]. He describes them extensively in a [[https://electronics.stackexchange.com/questions/30736/stm32f2-makefile-linker-script-and-start-up-file-combination-without-commercia][few places on Stack Overflow]]. Basically here he rolls his own .. everything. It's very greybeard. All the code is in your face - no libraries. Straight writting to registers. Definitely take a look!

- =PurpleAlien= has another setup - which is very close to what I'm doing. He described it [[https://www.purplealienplanet.com/node/69][on his website]] and the code is on the [[https://github.com/PurpleAlien/stm32-minimal][his github]]. It's a slightly different chip - but the steps should work almost identically for the =bluepill=.

* Anatomy of a build

** The Startup File
This first catch with programming the microcontroller is that the system can't simply start at the top of ~main()~ and work through the code like on a normal machine. When the chip is powered off the program is stored permanently in the Flash memory (ROM) and because there is no operating system to loading the program into RAM we need to do that ourselves in addition to initializing system clocks and event handlers.

B/c this process is independent of the rest of the program itself it's canonically separating it out into a "startup file". This is generally written in assembly and reused between projects. I have absolutely no clue how to write one from scratch. STM provides several different versions in their templates - all called =startup_stm32f103xb.s= and at the top of these files it explains the general purpose:

#+BEGIN_QUOTE
  *            This module performs:
  *                - Set the initial SP
  *                - Set the initial PC == Reset_Handler,
  *                - Set the vector table entries with the exceptions ISR address
  *                - Configure the clock system   
  *                - Branches to main in the C library (which eventually
  *                  calls main()).

#+END_QUOTE

Unfortunately each startup file looks nothing like any other and I have very little way to judge which one I need - so it's a bit of guessing game and hoping it'll work. I've copied one over that seems to work for me for the moment. If this becomes an issue then I might need to revisit it.

We need to tell CMake that this file will include assembly so that it doesnt' freak out

#+BEGIN_SRC cmake :tangle CMakeLists.txt
  enable_language(ASM)
  set(STARTUP_FILE "startup_stm32f103xb.s")
#+END_SRC

** The STM Libraries

Next we need actual libraries to write code with - otherwise we are kinda stuck writing assembly and poking at memory addresses with the datasheet. These are all provided in one bundle called *Cube* and it's on [[https://www.st.com/content/st_com/en/products/embedded-software/mcus-embedded-software/stm32-embedded-software/stm32cube-mcu-packages/stm32cubef1.html][the STM website]]. Here is a quick digest of what you get:

- The *BSP* has board specific peripheral libraries.. since we aren't using a board from STM - this really doesn't concern us.

- The *HAL* that comes from STM is the standard *Hardware Abstraction Layer*. It will be making some simplifying assumptions and do some stuff more automatically for you. I'm going to skip setting this up. Blinking a light should be pretty simple - so I'm shooting to get it working with simpler APIs

- Hidden inside of the *HAL* folder you will see files that are names =stm32f1xx_ll_*.c/h=. These actually form a seperate sub-library of sorts called the  *LL* API (for *Low Level*)

- The *CMSIS* ( Cortex Microcontroller Software Interface Standard ) : This library comes from ARM (/not STM/). It's split into several semi-independent components and provides a common base for all ARM devices (independent of vendor). The *HAL* and *LL API* are built on top of the *CMSIS*

Both the *HAL* and *CMSIS* need some chip-specific configuration - b/c while the API is standard, under the hood things will change from chip to chip (like memory addresses of things or clock information). I've bundled the *LL API* and the *CMSIS* together in a separate project [[https://geokon-gh.github.io/stm32f1-ll/index.html][stm32f1-ll]] ([[https://github.com/geokon-gh/stm32f1-ll/][github]]). It's also building with CMake so we can use it directly in our project (and you can skip registration and downloading the *Cube* thing). I recommend checking out that project's webpage for more details on how it works - but there is very little magic going on. 

The library bundle has been added as a submodule to this project, but if you forgot to clone recursively you can clone it right now into the project root with ~git clone https://github.com/geokon-gh/stm32f1-ll/~. Once we have it there we can just add it in

#+BEGIN_SRC cmake :tangle CMakeLists.txt
add_subdirectory(stm32f1-ll)
#+END_SRC

** Our blinky code (WIP)

Next we can write a little program to blink a light and put it into =/src/main.c=

#+BEGIN_SRC c
#include <stdlib.h>

#include "stm32f1xx.h"

#include "stm32f1xx_ll_gpio.h"
#include "stm32f1xx_ll_utils.h"
#include "stm32f1xx_ll_rcc.h"
//#include "stm32f1xx_conf.h"

void SystemClock_Config(void){

    /* Clock init stuff */ 
    
    LL_UTILS_PLLInitTypeDef sUTILS_PLLInitStruct = {LL_RCC_PLL_MUL_3, LL_RCC_PLL_DIV_3};
    LL_UTILS_ClkInitTypeDef sUTILS_ClkInitStruct = {LL_RCC_SYSCLK_DIV_1, LL_RCC_APB1_DIV_1, LL_RCC_APB2_DIV_1};
    
    LL_PLL_ConfigSystemClock_HSI(&sUTILS_PLLInitStruct, &sUTILS_ClkInitStruct);
    
    LL_Init1msTick(SystemCoreClock);
}

int main(void){

    /* Configure the system clock */
    SystemClock_Config();

    /* Let's pick a pin and toggle it */

    /* Use a structure for this (usually for bulk init), you can also use LL functions */   
    LL_GPIO_InitTypeDef GPIO_InitStruct;
    
    /* Enable the GPIO clock for GPIOA*/
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);

    /* Enable clock for SYSCFG */
    LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);

    /* Set up port A parameters */
    LL_GPIO_StructInit(&GPIO_InitStruct);                   // init the struct with some sensible defaults 
    GPIO_InitStruct.Pin = LL_GPIO_PIN_5;                    // GPIO pin 5; on Nucleo there is an LED
    GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;         // output speed
    GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;             // set as output 
    GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;   // make it a push pull
    LL_GPIO_Init(GPIOA, &GPIO_InitStruct);                  // initialize PORT A
 
    /* Toggle forever */
    while(1){
        LL_mDelay(250);
        LL_GPIO_TogglePin(GPIOA, LL_GPIO_PIN_5);
    }

    return 0;
}
#+END_SRC

Once there we can just add it as a special executable into our cmake
#+BEGIN_SRC cmake :tangle CMakeLists.txt
  add_executable(${PROJECT_NAME}.elf ${STARTUP_FILE} 
    src/main.c
    src/stm32f1xx_it.c
    src/system_stm32f1xx.c)
  target_include_directories(${PROJECT_NAME}.elf PUBLIC inc)
#+END_SRC
and then link it to our library
#+BEGIN_SRC cmake :tangle CMakeLists.txt
  target_link_libraries(${PROJECT_NAME}.elf ll )
#+END_SRC
** The toolchain

Now that we have the code to start up the chip and the code to blink a light we just need to specify the compiler and flags we will run. I'm building using =gcc-arm-none-eabi= and its associated tools. I did this on a Debian system where this version of gcc can be installed from the repository (name =gcc-arm-none-eabi=)

Canonically this is done in a separate file so that you can subsitute other possible toolchains (like for instance LLVM or custom versions of GCC). We won't be doing that here, but for the sake of convention I've written these configurations to a =toolchain.cmake=

#+BEGIN_SRC cmake :tangle toolchain.cmake
  set(CMAKE_SYSTEM_NAME Generic) # 'Generic' is used for embedded systems

  set(CMAKE_C_COMPILER arm-none-eabi-gcc)
  set(CMAKE_CXX_COMPILER arm-none-eabi-g++)
  set(CMAKE_ASM_COMPILER arm-none-eabi-gcc)

  # tells CMake not to try to link executables during its interal checks
  # things are not going to link properly without a linker script
  set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

  set(CMAKE_OBJCOPY arm-none-eabi-objcopy)
  set(CMAKE_OBJDUMP arm-none-eabi-objdump)
  set(CMAKE_SIZE arm-none-eabi-size)
  set(CMAKE_DEBUGGER arm-none-eabi-gdb)
  set(CMAKE_DEBUGGER arm-none-eabi-gdb)
  set(CMAKE_CPPFILT arm-none-eabi-c++filt)
#+END_SRC
If you skip writing a toolchain file then CMake will default to the system compiler and things will start to slowly go wrong for you (it generally doesn't blow up into your face here)

We then also need to let the compiler know our target architecture and some compiler options (taken from [[https://github.com/PurpleAlien/stm32-minimal/blob/master/Makefile][PurpleAlien]])

#+BEGIN_SRC cmake :tangle CMakeLists.txt
  target_compile_options(${PROJECT_NAME}.elf PUBLIC
    -Wall 
    -g 
    -std=gnu99 
    -Os
    -mthumb
    -mcpu=cortex-m3
    -mfloat-abi=soft
    -mlittle-endian
    -ffunction-sections 
    -fdata-sections
    -Werror 
    -Wstrict-prototypes 
    -Warray-bounds 
    -fno-strict-aliasing 
    -Wno-unused-const-variable 
    -specs=nano.specs 
    -specs=nosys.specs)
#+END_SRC
*TODO* Explain all of these...
** The Linker Script

The last bit to get everything working together is a special script that we feed to the linker (specified above in the toolchain)

When an application normally runs on a desktop machine it's generally running using virtual memory in a virtual application-specific address space. From the applications point of view it can manipulate it's own memory however it wants - and it's the operating system that then translates that into safe operations on the actually memory (for instance to insure that the applications doesn't touch any memory region it shouldn't)

On a simple microcontroller there is no operating system to manage the memory, and the memory is shared with other functionality. As we saw in the startup script, some addresses are reserved for peripherals, other addresses are for interrupts and reset bits, the stack and heap are allocated some place and there is also a split between ROM and RAM. So we can't just use the default linker and let it do whatever it wants. We need to specify the address space it can use via a linker script.

Here CMake is a deficient, but you can tell it about a linker script with the following lines:

#+BEGIN_SRC cmake :tangle CMakeLists.txt
        set_target_properties(
          ${PROJECT_NAME}.elf 
          PROPERTIES 
          LINK_FLAGS 
          "-T${PROJECT_SOURCE_DIR}/STM32F103RBTx_FLASH.ld \
           -Wl,--gc-sections \
           -Wl,-Map=${PROJECT_NAME}.map")
#+END_SRC

I'm appending this to the =CMakeLists.txt=, but it's maybe something that should be in the toolchain file.

I also added two more linker options (you can see it's a linker option by the =-Wl= before it)

- =--gc-sections= this tells the linker to remove unused code/data from the final executable. There is a pesky ~_exit()~ function referrence that will often get slipped into your executable by the compiler. B/c we are running on a microcontroller the code never exits (it can't quit and hand off executation to an OS after all!) so this exit needs to be removed by the linker. Otherwise the linker will complain you never defined an exit function.

- =-Map= prints a link map:
   + Where object files and symbols are mapped into memory.
   + How common symbols are allocated.
   + All archive members included in the link, with a mention of the symbol which caused the archive member to be brought in.

The link map is like a high-level overview of how your code looks like

More linker options are explained in details here: https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html

#+BEGIN_QUOTE
*Note*:in ~STM32Cube_FW_F1_V1.6.0/Middlewares~ there are additional libraries that sorta live on top of all of this and do more complicated stuff like TCP/IP USB..stuff and Filesystem things. Basically things that are kinda complicated you probably want to avoid writing yourself. I'm completely skipping this :)
#+END_QUOTE

* Getting the code on the chip
** Building

At this point we have all the files we need to build the code, so just go to a new empty directory and run

#+BEGIN_SRC
  cmake -DCMAKE_TOOLCHAIN_FILE=path/to/source/toolchain.cmake /path/to/source/
  make
#+END_SRC

Now in the build directory you'll have some build garbage, the link map =blinky.map= and =blinky.elf= - which is the code/executable that we want to get onto the bluepill.

** OpenOCD
The standard open source software for flashing the bluepill is OpenOCD. On fancier/more-expensive boards there will be a secondary chip that helps you flash the microcontroller. But on cheaper and more practical chips this part is omitted (b/c in a sense it's a waste to have the same chip on every single board). So to flash the bluepill you will need something to do the flashing with. I'm using a knock off =ST-LINK v2= I purchased on Taobao. (note the wiring is in a different order on the board and programmer)

[[file:st-link.jpeg]]

OpenOCD will provide us with an abstraction layer. It will communicate over JTAG or SWD or something to the chip and present us with a standard GDB server. Once it's setup we don't need to deal with the particulars of the how the chip is flashed. We simply go into GDB and tell GDB to upload new code and everything happens automatically for us behind the scenes.

Ofcourse the trick is to setup OpenOCD first :)

The software setup is rather baroque and not very obvious - but the [[http://openocd.org/documentation/][documentation]] is very thorough. You start from the beginning and just read very carefully sequentially and it will all make sense. Fortunately for us - the hardware we're using is very standard so we can use some already provided templates. When I install OpenOCD on my Debian system through ~apt-get install openocd~ the templates are in =/usr/share/openocd/scripts/board/=. After browsing some similar boards (like the stm32f4disovery) you kinda get the picture of how the configuration file should look (*THESE VALUES CHANGE BETWEEN POINT RELEASE OF OPENOCD. DOUBLE CHECK IF YOU HAVE ISSUE*)

#+BEGIN_SRC c :tangle openocd.cfg
source [find interface/stlink-v2.cfg]

transport select hla_swd

source [find target/stm32f1x_stlink.cfg]

reset_config none
#+END_SRC

and we have this saved to a =openocd.cfg=. For convenience we should also tell CMake to copy this file over to the build directory (where we need it when running openocd)

#+BEGIN_SRC cmake :tangle CMakeLists.txt
file(COPY
  openocd.cfg
  DESTINATION
  ${CMAKE_BINARY_DIR})
#+END_SRC

Now in our build directory we simply run ~openocd~ are *root* and it should launch the GDB server. It automatically will detect the ST-LINK V2 USB device in your USB port and then connect to the chip you have connected up. If something is misconfigured of not connected you can piece it together from the errors it gives back to you. Once everything is working you should have an output that looks something like

#+BEGIN_SRC
$ openocd
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select <transport>'.
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
none separate
srst_only separate srst_nogate srst_open_drain connect_deassert_srst
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v17 API v2 SWIM v4 VID 0x0483 PID 0x3748
Info : using stlink api v2
Info : Target voltage: 2.911807
Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints
#+END_SRC
.. and then it sorta just hangs\\
What's actually happening is that the GDB server is running in the background and you can connect to it.
#+BEGIN_QUOTE
*Note* I tried using the latest OpenOCD from the respository and it had some very weird unpredictable behavior (maybe was playing funny with my system OpenOCD). I'd look into this only if you system repository OpenOCD is older than 0.10.0 - b/c I've confirmed it works at this version

I also have strange power issue... it would on occassion not detect the chip or disconnect. I don't have any immediate suggestions other than turning it off and on again till it works..
#+END_QUOTE

** GDB

To test the GDB server you now need to make sure you have the right GDB installed. On Debian for some reason there is no ~arm-none-eabi-gdb~ package on testing/buster. So you can just install the whole GCC toolchain from ARM's website (assuming you're running on a x64 machine): https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads

Once you have it installed you need to run ~arm-none-eabi-gdb~ in our build directory and start a GDB session. The next few steps will connect to the OpenOCD server, stop the program running on it, unlock the chip, and load our new program

#+BEGIN_SRC 
> target remote localhost:3333
> monitor reset halt
> monitor stm32f1x unlock 0
> load blinky.elf
#+END_SRC

Then you can reset the chip and it should be running your code!


*** toolchain quirks
*Note:* Interestingly if I have my toolchain file pointing at the precompiled GCC files from ARM, my final =elf= file ends up looking different when I flash the chip

Using ARM's precompiled GCC =v.7.3.1= :
#+BEGIN_SRC
(gdb) load blinky.elf
Loading section .isr_vector, size 0x10c lma 0x8000000
Loading section .text, size 0x4bc lma 0x800010c
Loading section .rodata, size 0x4 lma 0x80005c8
Loading section .init_array, size 0x8 lma 0x80005cc
Loading section .fini_array, size 0x4 lma 0x80005d4
Loading section .data, size 0x434 lma 0x80005d8
Start address 0x800017c, load size 2572
Transfer rate: 10 KB/sec, 428 bytes/write.
#+END_SRC

Using the Debian repository GCC =v.6.3.1=:
#+BEGIN_SRC
(gdb) load blinky.elf
Loading section .isr_vector, size 0x10c lma 0x8000000
Loading section .text, size 0x52c lma 0x800010c
Loading section .rodata, size 0x4 lma 0x8000638
Loading section .init_array, size 0x8 lma 0x800063c
Loading section .fini_array, size 0x4 lma 0x8000644
Loading section .data, size 0x434 lma 0x8000648
Start address 0x80003e4, load size 2684
Transfer rate: 10 KB/sec, 447 bytes/write.
#+END_SRC
